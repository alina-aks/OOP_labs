## Паттерны
1. **Singleton**
   
   Паттерн Singleton гарантирует, что у класса есть только один экземпляр и предоставляет глобальную точку доступа к нему
   
   - [OrderService.cs](Lab3/Services/OrderService.cs) - гарантирует, что в системе будет только один экземпляр сервиса заказов для управления всеми заказами
  
      для нашей системы доставки нужен единый ресурс для управления всеми заказами, иначе появилось бы несогласованность данных о заказах и сложность в отслеживании всей системы. 

2. **Builder**

   Паттерн Builder (Строитель) используется для пошагового создания сложных объектов. Он отделяет конструирование объекта от его представления, позволяя использовать один и тот же процесс строительства для разных представлений объекта.

   - [OrderBuilder.cs](Lab3/Orders/OrderBuilder.cs) - пошаговое создания сложных объектов Order, заказ может иметь много опций
  
     объект Order имеет сложную структуру с кучей параметров(Тип заказа, список блюд из меню, данные клиента,адрес доставки,специальные условия). Благодаря Builder у нас есть постепенное конструирование заказа, выбор типа доставки и адреса
  
3. **State**

   Паттерн State (Состояние) позволяет объекту изменять своё поведение в зависимости от внутреннего состояния. При этом создаётся впечатление, что объект меняет свой класс. Он инкапсулирует состояния в отдельные объекты, что упрощает добавление и изменение логики.

   - папка [States](Lab3/States) - управление изменениями состояния заказа(подготовка, доставка, выполнен)

      Заказ имеет несколько состояний с разными функциями. поэтому нам нужно четкое разделение, возможность смены состояния и получение актуальной информации



4. **Strategy**

   Паттерн Strategy (Стратегия) позволяет определять семейство схожих алгоритмов, инкапсулировать их и делать взаимозаменяемыми. Это помогает изменять поведение объекта во время выполнения, не изменяя его код.

   - папка [Discounts](Lab3/Discounts) - определение семейства алгоритмов расчета скидок и возможности их замены во время расчета
  
     Система доставки имеет различные типы скидок, для этого каждый тип скидки это отдельная стратегия. это позволяет можно легко менять тип скидки.

5. **Template Method**

   Паттерн Template Method (Шаблонный метод) определяет скелет алгоритма, перекладывая реализацию некоторых шагов на подклассы. Это позволяет изменять отдельные этапы работы алгоритма, не изменяя его структуру.

   ```
   public class Order
    {
        public virtual decimal CalculateTotal() { ... }
    }
    
    public class StandardOrder : Order
    {
        public override decimal CalculateTotal()
        {
            decimal baseTotal = base.CalculateTotal();  
            return baseTotal + DeliveryFee; 
        }
    }
   ```
   

      Алгоритм расчета стоимости заказа имеет общую структуру, но разные типы заказов реализуют расчет по своему. Все заказы рассчитывают    стоимость блюд одинаково, но стоимость доставки разная. подклассы могут переопределять отдельные шаги, расчет един но его можно    кастомизировать под каждый тип доставки

6. **Observer** (не в полном объеме)

   Паттерн Observer (Наблюдатель) устанавливает отношение «один-ко-многим» между объектами: при изменении состояния издателя все его подписчики получают уведомление и автоматически обновляются. Это помогает ослабить связанность между источником событий и их потребителями.

   - [NotificationService.cs](Lab3/Services/NotificationService.cs) - реализация уведомлений о событиях в системе (создание заказа, изменение статуса)
  
     В доставке важно знать статус закада для разных целей:
Клиенту нужно получить уведомления о статусе заказа,
кухне нужно знать о новых заказах для приготовления,
курьеры должны получать заказы на доставку
